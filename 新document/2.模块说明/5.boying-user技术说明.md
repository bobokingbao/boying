# application.yml

## 多环境动态切换yml配置

在实际的的开发中，对于一个工程，经常会有多种环境配置，例如开发环境、测试环境、生产环境等。在不同的环境下，配置有可能是不一样的，比如接口地址、数据库连接配置等。为了避免频繁的修改配置文件，我们想要简便地切换各种环境配置。好在SpringBoot提供了这样的功能，可以很方便地切换不同场景下的配置。
	
对开发配置和生产环境做了配置。上面的配置是公共配置，下面我们分别配置了开发和生产的配置。`spring.profiles`表示配置的名称，`spring.profiles.active`表示要激活的环境，值和要切换的`spring.profiles`名称一致。默认激活的就是dev开发配置。
	
如果`spring.profiles.active`没有指定值，那么只会加载通用的配置。
	
工程打成jar包后，我们可以在运行的时候对配置进行选择，而不需要每次打包前都手动去修改`spring.profiles.active`的值。
	
例如在生产环境，我们可以使用release配置执行jar包`java -jar xxx.jar --spring.profiles.active=release`

如若配置:

```xml
spring:
  profiles:
    active: dev #默认为开发环境
```

会启动:`application.yml`与`application-dev.yml`

# config

## BoyingSecurityConfig

boying-security模块相关配置,在里面为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法。而且不添加基于路径的动态权限控制

## GlobalCorsConfig

全局跨域相关配置

## JacksonConfig

Jackson相关配置类,使得json不返回null的字段

## MyBatisConfig

MyBatis相关配置，控制dao或者mapper文件扫描位置

## SwaggerConfig

对boying-common的swagger相关组件进行自定义配置。Swagger API文档相关配置，主要是api扫描位置以及标题等





# Redis验证码

生成验证码时，将自定义的Redis键值加上手机号生成一个Redis的key,以验证码为value存入到Redis中，并设置过期时间为自己配置的时间（这里为120s）。校验验证码时根据手机号码来获取Redis里面存储的验证码，并与传入的验证码进行比对。

```java
# 自定义redis key
redis:
  database: boying
  key:
    authCode: 'user:authCode'
    user: 'user'
  expire:
    authCode: 90 # 验证码超期时间
    common: 86400 # 24小时


@Value("${redis.database}")
private String REDIS_DATABASE;
//    除验证码之外的过期时间
@Value("${redis.expire.common}")
private Long REDIS_EXPIRE;
@Value("${redis.expire.authCode}")
private Long REDIS_EXPIRE_AUTH_CODE;
//    用户以及验证码
@Value("${redis.key.user}")
private String REDIS_KEY_USER;
@Value("${redis.key.authCode}")
private String REDIS_KEY_AUTH_CODE;

@Override
public void setAuthCode(String telephone, String authCode) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    //redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
    redisService.set(key, authCode, REDIS_EXPIRE_AUTH_CODE);
}

@Override
public String getAuthCode(String telephone) {
    String key = REDIS_DATABASE + ":" + REDIS_KEY_AUTH_CODE + ":" + telephone;
    return (String) redisService.get(key);
}
```



# 登录功能

如果没有携带token，则使用login方法，登录成功后将用户上下文信息存入SecurityContext中，并且生成Token返回。

```java
    @Override
    public String login(UsernameLoginParam param) {
        String username = param.getUsername();
        String password = param.getPassword();

        System.out.println(passwordEncoder.encode(password));

        String token = null;
        //密码需要客户端加密后传递,但是传递的仍然是明文
        UserDetails userDetails = loadUserByUsername(username);
        if (!passwordEncoder.matches(password, userDetails.getPassword())) {
            throw new BadCredentialsException("密码不正确");
        }
//            获取该用户的上下文信息
//            username和password被获得后封装到一个UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
//            围绕该用户建立安全上下文（security context）
        SecurityContextHolder.getContext().setAuthentication(authentication);
        token = jwtTokenUtil.generateToken(userDetails);
        return token;
    }

    @Override
    public UserDetails loadUserByUsername(String username) {
        BoyingUser user = getByUsername(username);
        return new BoyingUserDetails(user);
    }

    @Override
    public BoyingUser getByUsername(String username) {
        BoyingUser user = boyingUserCacheService.getUser(username);
        if (user != null) return user; //缓存里面有数据

        //根据用户名查询是否存在
        user = boyingUserMapper.selectByUsername(username);

        //不能给过于详细的错误提示！
        if (user == null) Asserts.fail("用户名或密码错误");

        //账号未启用
        if (user.getAdminDelete()) Asserts.fail("账号未启用,请联系管理员!");

        boyingUserCacheService.setUser(user);//将查询到的数据放入缓存中
        return user;
    }
```
## BoyingUserDetails

```java
/**
 * SpringSecurity需要的用户详情
 */
public class BoyingUserDetails implements UserDetails {
    private final BoyingUser user;

    public BoyingUserDetails(BoyingUser user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的角色
        return Arrays.asList(new SimpleGrantedAuthority("TEST"));
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }

    @Override
    public boolean isEnabled() {
        return user.getAdminDelete();
    }
}
```
## getCurrentUser()

```java
    @Override
    public BoyingUser getCurrentUser() {
//        获取之前登录存储的用户上下文信息
        SecurityContext ctx = SecurityContextHolder.getContext();
        Authentication auth = ctx.getAuthentication();
        BoyingUserDetails userDetails = (BoyingUserDetails) auth.getPrincipal();
        System.out.println(userDetails.getUser());
        return userDetails.getUser();
    }
```

## BoyingSecurityConfig

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class BoyingSecurityConfig extends SecurityConfig {

    @Autowired
    private BoyingUserService boyingUserService;

    /**
     * 注解@Bean放在方法上，产生一个Bean并且交给Spring容器管理
     * 定义用户信息
     *
     * @return
     */
    @Bean
    public UserDetailsService userDetailsService() {
        //为UserDetailsService定义一个适用与boying-user组件的获取登录用户信息的方法
        return username -> boyingUserService.loadUserByUsername(username);
    }
    //不添加基于路径的动态权限控制
}
```

当有token时，过滤器会直接使用token进行登录：

```java
@Override
protected void doFilterInternal(HttpServletRequest request,
                                HttpServletResponse response,
                                FilterChain chain) throws ServletException, IOException
{
    //请求头有字段Authorization，并且以‘Bearer ’开头
    String authHeader = request.getHeader(this.tokenHeader);
    if (authHeader != null && authHeader.startsWith(this.tokenHead))
    {
        String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
        String username = jwtTokenUtil.getUserNameFromToken(authToken);
        LOGGER.info("checking username:{}", username);
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null)
        {
            //SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限）
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            //验证用户名和是否已过期
            if (jwtTokenUtil.validateToken(authToken, userDetails))
            {
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                LOGGER.info("authenticated user:{}", username);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
    }
    chain.doFilter(request, response);
}
```